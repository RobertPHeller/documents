                                         1 Introduction (Informative)

   Minimal introductory material, only the stuff that's absolutely needed to understand the Standard.

   This standard is organized in terms of specific sub-parts of the Train Protocol function. OpenLCB has
   previously made things like that separate, so you specify which protocols you obey, not which parts.
    This should either be made all required, or split up.

                                         2 Intended Use (Informative)

   “Train Nodes” are operated through this.

                                     3 References and Context (Normative)

   Citations to other docs, as needed.

   Node implementing the Train Protocol must implement:

     * Event Transfer Protocol

     * Datagram Transfer Protocol

     * Memory Configuration Protocol (optional?)

     * SNII and/or ACDI?

                                               4 Speed Control

   Speed Control commands are a kind of Traction Control command, and as such are messages with MTI
   priority 1, index 15. On CAN, this translates into an MTI of 0x05E8, or [195E8sss] fd dd xx xx xx xx xx
   xx. Thus, on CAN, we have 6 bytes available (the first two are given over to the destination NID), and
   so references to Byte 0 of a Traction Control command refer to Byte 2 of the CAN data.

    

   Command         Byte 0 Byte 1      Byte 2      Byte 3 Byte 4 Byte 5 
   Set Train Speed 0x00   Data byte 1 Data byte 2                      
   Emergency Stop  0x02                                                

   For OpenLCB, the speed and direction to set is encoded as a half-precision floating point number (aka
   'float16'), with positive numbers indicating forward direction, negative indicating reverse, and
   (signed) zero indicating full (non-emergency) stop. The value specifies a speed in scale meters per
   second (scale-m/s).

   Rationale: The use of a 16-bit floating point permits relatively precise speed commands, especially at
   lower speeds; such fine granulatity ensures not just fine-grained control over the locomotive, but helps
   avoid aliasing issue that arise during the conversion to lower resolution system-specific speed commands
   (i.e. DCC's 14 or 28-step commands).

   The use of meters per second is somewhat arbitrary, and reflects standard velocity units used throughout
   the metric-speaking world. By standardizing on m/s, we avoid any future unit conversion issues.

   The use of scale meters per second has two distinct advantages. First, it permits us to transmit speed
   commands in a scale-independent way. Second, and because of this, it reduces the number of parameters
   that must be estimated when controlling a locomotive that has not yet been speed-calibrated (which, for
   new users using existing digital control systems, will be all of their models). For example, on a DCC
   system, if I issue a command to proceed at 30mph, the command station must convert the value in the
   speed command from 30mph to an interger in the range [0-26] (for 28-speed-step control). The command
   station need only estimate what a reasonable top speed for a locomotive might be: Let us say, 100mph.
   Thus, the command station could reasonably estimate that 30mph translates to speed step 8.

   The alternative possibilities considered to date are absolute speed using real units (as opposed to
   scale units), and relative speed units. The difficulty with relative speed units (i.e., percentage of
   full throttle), is that they are ambiguous, and preclude the possibility of performing physical
   simulations in the cab controller, at least without completely abandoning the particular interpretations
   assigned to sped values. The difficulty with using real (as opposed to scale) units is that it requires
   the estimation of an additional parameter for uncalibrated locomotives, specifically the train's scale.
   If I issue a command to a DCC locomotive to proceed at 0.1 (real)m/s, the command station must not only
   understand what a reasonable top speed for a train is, but how to scale the speed appropriately, as 0.1
   m/s might be quite fast for Z scale, but quite slow for G. As there is really no reasonable scale to use
   as a default, users must configure their digital command station to set the scale for either the entire
   layout, or on a per-model basis—an additional configuration step that is easily avoided by the mechanism
   for scale units described above.

                                              5 Function Control

   Function control is required, though any specific functions are not.

5.1 Function Operation

   "Functions" like "horn", "headlight", etc are key user features when operating modern decoders. But
   they're also configuration-like, in that they effect the operation of the device.

   How to handle them for a native OpenLCB piece of rolling stock, and for legacy ones via e.g. DCC?

   We could take the purist approach and say "configuration is configuration, it's all the same". But that
   ignores that many people are going to want "Bell" to appear (automatically) on their throttle, but not
   so many are going to want "Kp back-emf correction factor" to appear there.

   People just think about operating and configuring their locomotives as separate things. (Though e.g.
   "Master Volume" can cross the line)

   This doesn't mean that we can't use the same protocol for all other of them. A mixture of memory
   configuration and CDI should do just fine. It just means that we need to find a way to include clueing
   information for the throttles on e.g. what to present.

   Function Storage and Description

   Function values are stored in the 0xF9 memory space. "Function Definition Information", similar in
   intent to Configuration Definition Information (CDI) is stored in XML format in address space 0xFA to
   provide user-oriented context. That includes:

   Memory layout of the function values, allowing for multiple data types from binary (one and off for
   lights) through integer values (for e.g. sound intensities) and strings (sign displays?).

   Function naming, so that a throttle can display useful names to the user such as "Bell", "Coupler Clank"
   and "Master Volume". This includes internationalization of those labels.

   What else needs to be conveyed? "Make this prominent on the throttle"? "Have this there, just a little
   less prominent"? "Seriously, nobody cares about this option, bury it"?

   At present, there are no default values that e.g. associate "Bell" with a particular location or
   function. These are thought to be too brittle, and there are just too many possibilities to be useful
   (see the unscientific and incomplete Survey of existing function names).

   Outputs vs Functions

   Tools like DecoderPro and its decoder-definition files make a distinction between "functions", which are
   the control commands sent via e.g. DCC, and "outputs", which are the things that a decoder can do:
   Control an electrical output, make a sound, etc. This distinction is useful because one of the
   configuration options in (some) DCC decoders is a mapping between the functions and the outputs, useful
   in a world where throttles generally have only about a dozen buttons, but decoders have many output
   options.

   OpenLCB makes a clean separation between functions, which are the control operations, and all
   configuration & physical information, which lives in the memory configuration and CDI. If there's to be
   a mapping, it's defined through the CDI.

    

5.2 Function Definition

                                            6 Train Configuration

   Trains are OpenLCB nodes just like any other. As such, the Memory Configuration protocol can be used to
   configure them, the Configuration Description Information system can be used to make that process user
   friendly, etc. There's nothing traction-specific in these techniques, which are available any time that
   the train node is connected to the OpenLCB.

   The configuration information in a train can include the user documentation that's sometimes referred to
   as "roster information". This might include owner name, prototype railroad and road number, information
   about the particular model's construction, etc. As yet, OpenLCB has no standards nor conventions on this
   information.

   One approach to standards in this area would be extend ACDI/SNIP. Those currently have a block for
   manufacturer identification, and a block for user identification. Those are both versioned. We could
   take (one of) several approaches:

     * Extend them with a third block, only present when the node implements the train protocol (as seen in
       PIP). To allow later introduction of more types, this block would have some versioning/type
       information, but that's straightforward.

     * Create a version 2 of the user block, which holds additional data. (This would be using 2 as a
       format identifier, rather than a version number; that might make versioning complicated)

   Suitable content for a (first version of) this might be (from [
   http://jmri.org/JavaDoc/doc/jmri/jmrit/roster/RosterEntry.html JMRI roster], see also similar concepts
   in [rocrail.net RocRail]):

     * Road Name

     * Road Number

   (Manufacturer, model, owner description, comments, etc are already present in ACDI/SNI)

   For DCC locomotives, more terms might be desired:

     * DCC Address

     * Decoder Type (Manufacturer, model)

    

                                            7 Train Identification

   OpenLCB Train nodes use:

     * The Event Transport protocol to locate Train nodes

     * PIP for enquiry about the support

     * Memory configuration, CDI, ACDI and SNII for indentification of a specific train node.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   Train Acquisition Protocol is necessary because the train operator doesn't want to pick up a throttle
   and enter "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the
   desired locomotive from a list of those available. (A throttle should still allow the operator to
   directly enter the address, when that's what the operator wants to do.)

   The train acquisition process simplifies locating desired train nodes so that small hand-held throttle
   nodes can efficiently take part. It does this using several approaches, which can be used as needed by
   throttles:

     * Events are used to announce the existence and status of Train nodes

     * Train nodes supporting legacy equipment with its own addressing conventions will appear at
       well-known node addresses based on that legacy addressing

     * Train nodes will generally implement the Simple Node Information protocol so that throttles can get
       basic, user-readable identification from them

     * A search protocol is (being) defined to make it possible to locate individual Train nodes without
       having to read information from all of them

   So that other nodes can find them, Train nodes must produce the well-known reserved event
   01.01.00.00.00.00.03.03. This means they must sent that event in a Producer/Consumer Event Report
   message when they power up, and reply to requests for producers of that event. They must also produce
   the reserved event 01.01.00.00.00.00.03.04 if they are not allocated to a physical train (e.g. an unused
   proxy Train node), or 01.01.00.00.00.00.03.05 if they are allocated to a train (e.g. a real Train node
   or proxy Train node that is in use).  (Both show up; only one is valid at a time)

   For the special case of nodes that implement connections to legacy equipment (proxies), specific
   addresses have been assigned. For example, nodes that implement communications to DCC decoders must be
   available at the well-known node ID 6.1.0.(CS number).(address), where address is the long or short NMRA
   DCC address for a decoder. (Nodes that communicate with a particular decoder may also appear at other
   node addresses, if desired)

   SNIP will be used to carry both manufacturer-provided and user-provided information about the particular
   train node. In particular, the user (Node) Name and (Node) Description fields are to be used to hold
   train identification information that can be retrieved and presented by throttles for selection.

   A search protocol needs to be defined to allow efficient location of specific train nodes on large
   OpenLCB installations. It provides a general or field-specific search over the SNIP information,
   returning the Node IDs of matching Train Nodes. One proposal, which is not based on memory configuration
   & SNIP, is available here in pdf format and here in OpenOffice Writer.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   This is necessary because the train operator doesn't want to pick up a throttle and enter
   "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the desired
   locomotive from a list of those available. (Throttle should still allow the operator to directly enter
   the address, when that's what the operator wants to do.)

   The Train Acquisition Protocol simplifies this process so that small hand-held throttle nodes can
   efficiently take part.

   The protocol uses three well-known event IDs:

   01.01.00.00.00.00.03.03 (isTrain) This node is a Train (or Train Proxy)

   01.01.00.00.00.00.03.04 (isIdleProxy) This node is an idle Train Proxy, not associated with a Train

   01.01.00.00.00.00.03.05 (isInUseProxy) This node is an in-use Train or Train Proxy

   (The last two are specific to proxy-based implementations, here for completeness; see e.g. the DCC page
   for more info)

   All Train nodes produce the isTrain event. That means they announce it when they first come up, respond
   to EventProduced requests for it, and list it when replying to IdentifyEvent messages.

   An EventProduced request will therefore find all the train nodes on the OpenLCB, and further protocols
   can be used to get additional information on the individual Train nodes it locates.

                                          8 Legacy Train Operations

   (Should be in TN? Is there any standard interchange here expect assignment?)

8.1 Node Assignment

8.2 Speed and Function Control

    

   See https://sourceforge.net/apps/mediawiki/openlcb/index.php?title=Function_Control

    

8.3 Configuration

    

    

    

    

   Table of Contents

   1 Introduction (Informative)

   2 Intended Use (Informative)

   3 References and Context (Normative)

   4 Speed Control

   5 Function Control

   5.1 Function Operation

   5.2 Function Definition

   6 Train Configuration

   7 Train Identification

   8 Legacy Train Operations

   8.1 Node Assignment

   8.2 Speed and Function Control

   8.3 Configuration

    
