                                         1 Introduction (Informative)

   Minimal introductory material, only the stuff that's absolutely needed to understand the Standard.

   This standard is organized in terms of specific sub-parts of the Train Protocol function. OpenLCB has
   previously made things like that separate, so you specify which protocols you obey, not which parts.
    This should either be made all required, or split up.

                                         2 Intended Use (Informative)

   “Train Nodes” are operated through this.

                                     3 References and Context (Normative)

   Citations to other docs, as needed.

   Node implementing the Train Protocol must implement:

     * Event Transfer Protocol

     * Datagram Transfer Protocol

     * Memory Configuration Protocol (optional?)

     * SNII and/or ACDI?

                                               4 Speed Control

   Speed Control commands are a kind of Traction Control command, and as such are messages with MTI
   priority 1, index 15. On CAN, this translates into an MTI of 0x05E8, or [195E8sss] fd dd xx xx xx xx xx
   xx. Thus, on CAN, we have 6 bytes available (the first two are given over to the destination NID), and
   so references to Byte 0 of a Traction Control command refer to Byte 2 of the CAN data.

    

   Command         Byte 0 Byte 1      Byte 2      Byte 3 Byte 4 Byte 5 
   Set Train Speed 0x00   Data byte 1 Data byte 2                      
   Emergency Stop  0x02                                                

   For OpenLCB, the speed and direction to set is encoded as a half-precision floating point number (aka
   'float16'), with positive numbers indicating forward direction, negative indicating reverse, and
   (signed) zero indicating full (non-emergency) stop. The value specifies a speed in scale meters per
   second (scale-m/s).

                                              5 Function Control

   Function control is required, though any specific functions are not.

5.1 Function Operation

   Function values are stored in the 0xF9 memory space. They are written using the memory configuration
   protocol.

5.2 Function Definition

   “Function Definition Information”, similar in intent to Configuration Definition Information (CDI) is
   stored in XML format in address space 0xFA to provide user-oriented context. That includes:

     * Memory layout of the function values, allowing for multiple data types from binary (one and off for
       lights) through integer values (for e.g. sound intensities) and strings (sign displays?).

     * Function naming, so that a throttle can display useful names to the user such as "Bell", "Coupler
       Clank" and "Master Volume". This includes internationalization of those labels.

   What else needs to be conveyed? "Make this prominent on the throttle"? "Have this there, just a little
   less prominent"? "Seriously, nobody cares about this option, bury it"?

   At present, there are no default values that e.g. associate "Bell" with a particular location or
   function. These are thought to be too brittle, and there are just too many possibilities to be useful
   (see the unscientific and incomplete Survey of existing function names).

                                            6 Train Configuration

   Trains are OpenLCB nodes just like any other. As such, the Memory Configuration protocol can be used to
   configure them, the Configuration Description Information system can be used to make that process user
   friendly, etc. There's nothing traction-specific in these techniques, which are available any time that
   the train node is connected to the OpenLCB.

   The configuration information in a train can include the user documentation that's sometimes referred to
   as "roster information". This might include owner name, prototype railroad and road number, information
   about the particular model's construction, etc. As yet, OpenLCB has no standards nor conventions on this
   information.

   One approach to standards in this area would be extend ACDI/SNIP. Those currently have a block for
   manufacturer identification, and a block for user identification. Those are both versioned. We could
   take (one of) several approaches:

     * Extend them with a third block, only present when the node implements the train protocol (as seen in
       PIP). To allow later introduction of more types, this block would have some versioning/type
       information, but that's straightforward.

     * Create a version 2 of the user block, which holds additional data. (This would be using 2 as a
       format identifier, rather than a version number; that might make versioning complicated)

   Suitable content for a (first version of) this might be (from [
   http://jmri.org/JavaDoc/doc/jmri/jmrit/roster/RosterEntry.html JMRI roster], see also similar concepts
   in [rocrail.net RocRail]):

     * Road Name

     * Road Number

   (Manufacturer, model, owner description, comments, etc are already present in ACDI/SNI)

   For DCC locomotives, more terms might be desired:

     * DCC Address

     * Decoder Type (Manufacturer, model)

    

                                            7 Train Identification

   OpenLCB Train nodes use:

     * The Event Transport protocol to locate Train nodes

     * PIP for enquiry about the support

     * Memory configuration, CDI, ACDI and SNII for indentification of a specific train node.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   Train Acquisition Protocol is necessary because the train operator doesn't want to pick up a throttle
   and enter "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the
   desired locomotive from a list of those available. (A throttle should still allow the operator to
   directly enter the address, when that's what the operator wants to do.)

   The train acquisition process simplifies locating desired train nodes so that small hand-held throttle
   nodes can efficiently take part. It does this using several approaches, which can be used as needed by
   throttles:

     * Events are used to announce the existence and status of Train nodes

     * Train nodes supporting legacy equipment with its own addressing conventions will appear at
       well-known node addresses based on that legacy addressing

     * Train nodes will generally implement the Simple Node Information protocol so that throttles can get
       basic, user-readable identification from them

     * A search protocol is (being) defined to make it possible to locate individual Train nodes without
       having to read information from all of them

   So that other nodes can find them, Train nodes must produce the well-known reserved event
   01.01.00.00.00.00.03.03. This means they must sent that event in a Producer/Consumer Event Report
   message when they power up, and reply to requests for producers of that event. They must also produce
   the reserved event 01.01.00.00.00.00.03.04 if they are not allocated to a physical train (e.g. an unused
   proxy Train node), or 01.01.00.00.00.00.03.05 if they are allocated to a train (e.g. a real Train node
   or proxy Train node that is in use).  (Both show up; only one is valid at a time)

   For the special case of nodes that implement connections to legacy equipment (proxies), specific
   addresses have been assigned. For example, nodes that implement communications to DCC decoders must be
   available at the well-known node ID 6.1.0.(CS number).(address), where address is the long or short NMRA
   DCC address for a decoder. (Nodes that communicate with a particular decoder may also appear at other
   node addresses, if desired)

   SNIP will be used to carry both manufacturer-provided and user-provided information about the particular
   train node. In particular, the user (Node) Name and (Node) Description fields are to be used to hold
   train identification information that can be retrieved and presented by throttles for selection.

   A search protocol needs to be defined to allow efficient location of specific train nodes on large
   OpenLCB installations. It provides a general or field-specific search over the SNIP information,
   returning the Node IDs of matching Train Nodes. One proposal, which is not based on memory configuration
   & SNIP, is available here in pdf format and here in OpenOffice Writer.

   Trains are OpenLCB nodes just like any other. As such, they can take part in protocols such as Node
   Verification and Simple Node Information which allows other nodes to learn about them.

   This is necessary because the train operator doesn't want to pick up a throttle and enter
   "06.011.00.02.1F.2D" (a node ID), or even "110 Long" (a DCC address), but rather just pick the desired
   locomotive from a list of those available. (Throttle should still allow the operator to directly enter
   the address, when that's what the operator wants to do.)

   The Train Acquisition Protocol simplifies this process so that small hand-held throttle nodes can
   efficiently take part.

   The protocol uses three well-known event IDs:

   01.01.00.00.00.00.03.03 (isTrain) This node is a Train (or Train Proxy)

   01.01.00.00.00.00.03.04 (isIdleProxy) This node is an idle Train Proxy, not associated with a Train

   01.01.00.00.00.00.03.05 (isInUseProxy) This node is an in-use Train or Train Proxy

   (The last two are specific to proxy-based implementations, here for completeness; see e.g. the DCC page
   for more info)

   All Train nodes produce the isTrain event. That means they announce it when they first come up, respond
   to EventProduced requests for it, and list it when replying to IdentifyEvent messages.

   An EventProduced request will therefore find all the train nodes on the OpenLCB, and further protocols
   can be used to get additional information on the individual Train nodes it locates.

                                          8 Legacy Train Operations

   (Should be in TN? Is there any standard interchange here expect assignment?)

8.1 Node Assignment

8.2 Speed and Function Control

    

   See https://sourceforge.net/apps/mediawiki/openlcb/index.php?title=Function_Control

    

8.3 Configuration

    

    

                                                      9

    

   Table of Contents

   1 Introduction (Informative)

   2 Intended Use (Informative)

   3 References and Context (Normative)

   4 Speed Control

   5 Function Control

   5.1 Function Operation

   5.2 Function Definition

   6 Train Configuration

   7 Train Identification

   8 Legacy Train Operations

   8.1 Node Assignment

   8.2 Speed and Function Control

   8.3 Configuration

   9

    
